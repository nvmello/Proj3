#include "threads.h"


TCB_t *EmptyQ;   //sem waitQ
TCB_t *FullQ;    //sem waitQ


/**
 * I think emptyVal represents how many spots can be filled until the buffer is full
 * and fullVal represents how many spots need to be consumed before the buffer is empty
 */
int emptyVal = 0;   
int fullVal= 0;

int bufItems = 0;
int in = 0;
int out = 0;
int * bSize;
int * buf;

/**
 * P(sem)
 * The P routine decrements the semaphore, 
 * and if the value is 0 or less than zero then 
 * blocks the process in the queue associated with the semaphore.
 */
void P_Wait(struct TCB_t **waitQ, int * val, int threadID){
    

    while ((*val)<=0) //block process
    {
        
        //To perform task (a) for every semaphore you declare you have to create a new queue semQ. 
        struct TCB_t *temp = newItem();
        //Whenever a thread executed P(S) and S <= 0 the TCB of the thread gets deleted from the RunQ
        
        temp = delQueue(&(runQ));
        
        // and inserted at the end of the semQ. 
        addQueue(waitQ,temp);
        if (EmptyQ == NULL)
        {
            printf("\n Consumer %d is waiting \n",threadID); 
        } if (FullQ == NULL)
        {
            printf("\n Producer %d is waiting \n",threadID); 
        }
        if (runQ==NULL)
        {
            exit(0);
        }
        //swapcontext((where current context gets stored),());
        swapcontext(&(temp->context), &(runQ->context));
    }
    (*val)--;
}

/**
 * V(sem)
 * The V routine increments the semaphore,
 * and if the value is 0 or negative, 
 * then takes a PCB out of the semaphore queue 
 * and puts it into the run queue. 
 * Note: The V routine also "yields" to the next runnable process. //this is important.
 */
void V_Signal(struct TCB_t **waitQ, int * val){

    if ((*val) >= 0 && (*waitQ) != NULL) //if val <= 0 and waitQ is not empty
    {
        
        struct TCB_t *temp = newItem();
        //unblock one process. To unblock a process, 
        //delete one process from the waitQ 
        temp = delQueue(waitQ);

        //and add at the end of the RunQ. 
        addQueue(&runQ, temp);
    }
    (*val)++;

    //This way the processes can perform yield and the unblocked process will execute again.
    //yield(); 
}

void Producer(int threadID, int n){
    int i = 0;

    while (i<n)
    {
        P_Wait(&EmptyQ,&emptyVal,threadID);
        
        buf[in] = threadID;
        in = (in+1)%(*bSize);
        bufItems++;
        printf("\n Producer %d is producing item number %d \n", threadID, i+1);
        
        V_Signal(&FullQ, &fullVal);
        i++;
        if (i==n)
        {
            //what happens when i = n?
            TCB_t * temp;
            temp = delQueue(&runQ);

            if (runQ==NULL)
            {
                exit(0);
            }

            swapcontext(&(temp->context),(&(runQ->context)));
            //not only do you have to switch to another process 
            //but you also have to delete the current process from the runQ
        } else{
            yield();
        }
    }
    

}


void Consumer(int threadID, int n){
    int item;
    int i =0;
    
    while (i<n)
    {
        P_Wait(&FullQ,&fullVal,threadID);
        
        
        printf("\n Consumer %d is consuming item generated by Producer %d \n", threadID, buf[out]);
        out = (out+1)%(*bSize);
        V_Signal(&EmptyQ, &emptyVal);
        
        i++;
    
        if (i==n)
        {
            //what happens when i = n?
            TCB_t * temp;
            temp = delQueue(&runQ);

            if (runQ==NULL)
            {
                exit(0);
            }
            

            swapcontext(&(temp->context),(&(runQ->context)));
            //not only do you have to switch to another process 
            //but you also have to delete the current process from the runQ
        } else{
            yield();
        }
    } 


}

